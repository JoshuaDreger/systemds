#
# DESCRIPTION:
# ------------------------------------------------------------
# This script optimizes the parameters for an hmm model given Observation Sequences
# It does this by maximizing the Likelihood of the Observation Sequences occuring.
# It therefore uses the Baum Welch Algorithm.
# Basing on an Expectation Maximization strategy the Algorithm updates the hmm model parameters iteratively.
# ------------------------------------------------------------------------------------------
#
# INPUT:
# --------------------------------------------------------------------------------------------
# observations_sequences    Observation Sequences to train the model on
# iterations_count          Number of Iterations the Probabilities should be updated
# start_prob                Start probabilities
# transition_prob           Transition probabilities
# emission_prob             Emission probabilities
# ----------------------------------------------------------------------------------------
#
# OUTPUT:
# --------------------------------------------------------------------------------------------
# start_prob                Optimized Start probabilities
# transition_prob           Optimized Transition probabilities
# emission_prob             Optimized Emission probabilities
# --------------------------------------------------------------------------------------------

m_hmm_fit = function(matrix[Double] observations_sequences, Integer iterations_count,
                     matrix[Double] start_prob, matrix[Double] transition_prob,
                     matrix[Double] emission_prob)
    return(matrix[Double] start_prob, matrix[Double] transition_prob,
           matrix[Double] emission_prob)
    {
        hiddenstates_count = ncol(transition_prob)
        observation_count = ncol(emission_prob)
        sequence_length = ncol(observation_sequence)
        diff_tracker = matrix(NaN, rows = 2, cols = iterations_count)
        diff_tracker[1,] = matrix(seq(1,iterations_count), rows=1,cols=iterations_count)

        for (iteration in 1:iterations_count) {
            forward_prob = forward(observation_sequence, start_prob, transition_prob, emission_prob, hiddenstates_count, sequence_length)
            backward_prob = backward(observation_sequence, transition_prob, emission_prob, hiddenstates_count, sequence_length)

            observations_prob_forward = as.scalar(logSumExp(M = forward_prob[2:hiddenstates_count,sequence_length]))

            expected_transition_prob = expected_transition(observation_sequence, transition_prob, emission_prob, forward_prob, backward_prob, observations_prob_forward, hiddenstates_count, sequence_length, observation_count)
            expected_emission_prob = expected_emission(observation_sequence, transition_prob, emission_prob, forward_prob, backward_prob, observations_prob_forward, hiddenstates_count, sequence_length, observation_count)



            print("emission_prob at step " + toString(iteration) + ": \n" + toString(emission_prob) + "\n")
            print("expected_emission_prob at step " + toString(iteration) + ": \n" + toString(expected_emission_prob) + "\n")

            print("transition_prob at step " + toString(iteration) + ": \n" + toString(transition_prob) + "\n")
            print("expected_transition_probsion_prob at step " + toString(iteration) + ": \n" + toString(expected_transition_prob) + "\n")

            difference = sqrt(sum((emission_prob - expected_emission_prob)^2)) + sqrt(sum((transition_prob - expected_transition_prob)^2))
            diff_tracker[2,iteration] = difference

            print("difference at step " + toString(iteration) + ": \n" + toString(difference) + "\n")

            transition_prob = expected_transition_prob
            emission_prob = expected_emission_prob
        }
    }


forward = function(matrix[Double] observations_sequences, matrix[Double] start_prob, 
                   matrix[Double] transition_prob, matrix[Double] emission_prob)
    return(matrix[double] forward_prob)
    {   
        hiddenstates_count = ncol(transition_prob)
        observations_count = ncol(observations_sequences)
        forward_prob = matrix(0, rows = hiddenstates_count, cols = observations_count)

        observation = as.scalar(observations_sequences[1,1])
        forward_prob[,1] = log(start_prob * emission_prob[,observation])

        for (k in 2:observations_count) {
            observation = as.scalar(observations_sequences[1,k])
            forward_prob[,k] = log(transition_prob %*% emission_prob[,observation]) + forward_prob[,k-1]
        }
    }


backward = function(matrix[Double] observations_sequences, matrix[Double] transition_prob, 
                    matrix[Double] emission_prob)
    return(matrix[double] backward_prob)
    {   
        hiddenstates_count = ncol(transition_prob)
        observations_count = ncol(observations_sequences)
        backward_prob = matrix(0, rows = hiddenstates_count, cols = observations_count)

        for (k in (observations_count-1):1) {
            observation = as.scalar(observations_sequences[1,k])
            backward_prob[,k] = log(transition_prob %*% emission_prob[,observation]) + backward_prob[,k+1]
        }
    }

expected_transition = function(matrix[Double] observation_sequence, matrix[Double] transition_prob, 
                               matrix[Double] emission_prob, matrix[Double] forward_prob,
                               matrix[Double] backward_prob, Double observations_prob_forward,
                               Integer hiddenstates_count, Integer sequence_length,
                               Integer observation_count)
    return(matrix[double] expected_transition_prob)
    {
        expected_transition_prob = matrix(0, rows = hiddenstates_count, cols = hiddenstates_count)
        sequence_emission_prob = matrix(0, rows = 1, cols = sequence_length)
        for (x in 1:hiddenstates_count) {
            for (y in 1:hiddenstates_count) {
                for (k in 1:sequence_length) {
                    observation = as.scalar(observation_sequence[1,k])
                    sequence_emission_prob[1,k] = log(emission_prob[y,observation])
                }
                tmp_transition_prob = forward_prob[x,1:sequence_length-1] + backward_prob[y,2:sequence_length] + log(transition_prob[x,y]) + sequence_emission_prob[1,2:sequence_length]
                #tmp_transition_prob = forward_prob[x,] + backward_prob[y,] + log(transition_prob[x,y]) + sequence_emission_prob
                expected_transition_prob[x,y] = exp(logSumExp(M = tmp_transition_prob) - observations_prob_forward)
            }
            # This line is not in the R implementation
            # expected_transition_prob[x,] = expected_transition_prob[x,] / colSums(expected_transition_prob)
        }
        expected_transition_prob = expected_transition_prob / rowSums(expected_transition_prob)
    }

expected_emission = function(matrix[Double] observation_sequence, matrix[Double] transition_prob, 
                             matrix[Double] emission_prob, matrix[Double] forward_prob,
                             matrix[Double] backward_prob, Double observations_prob_forward,
                             Integer hiddenstates_count, Integer sequence_length,
                             Integer observation_count)
    return(matrix[double] expected_emission_prob)
    {
        expected_emission_prob = matrix(0, rows = hiddenstates_count, cols = observation_count)
        for (y in 1:observation_count) {
            sequence_emission_prob = matrix(0, rows = hiddenstates_count, cols = sequence_length)
            i = 0
            for (k in 1:sequence_length) {
                    observation = as.scalar(observation_sequence[1,k])
                    if(observation == y) {
                        i += 1
                        sequence_emission_prob[,i] = forward_prob[,k] + backward_prob[,k]
                    }
                }
            if (i == 0){
                expected_emission_prob[,y] = matrix(0, rows = hiddenstates_count, cols = 1)
            } else {
                expected_emission_prob[,y] = exp(logSumExp(M = sequence_emission_prob[,1:i], margin = "rows") - observations_prob_forward)
            }
        }
        expected_emission_prob = expected_emission_prob / rowSums(expected_emission_prob)
    }
